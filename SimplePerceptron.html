<html>

<head>
  <style>
    #PerceptronCanvas {
      border: 3px solid black;
    }

    #PerceptronBlueClassButton {
      color: blue;
    }

    #PerceptronRedClassButton {
      color: red;
    }

    .PerceptronActiveClassButton {
      background-color: yellow;;
    }

    .PerceptronTrainButton {
      color: green;
    }

    .PerceptronClassifyButton {
      color: #0088AA;
    }

    .PerceptronControlButton {
      font-weight: bold;
      margin-right: 20px;
      width: 110px;
    }
  </style>

  <script type="text/javascript">
    // Global variables:
    const DATA_POINT_RENDER_RADIUS = 4;
    const LEARNING_RATE = 0.5;
    const RED_CLASS_VALUE = 0;
    const BLUE_CLASS_VALUE = 1;

    let currentlySelectedTrainingClass = BLUE_CLASS_VALUE;
    let dataPoints = [];

    class PerceptronDataPoint {
      constructor(xCoordinate, yCoordinate, dataClass, predictedClass = null) {
        this._xCoordinate = xCoordinate;
        this._yCoordinate = yCoordinate;
        this._dataClass = dataClass;
        this._predictedClass = predictedClass;
      }
      getDataClass() {
        return this._dataClass;
      }
      getXCoordinate() {
        return this._xCoordinate;
      }
      getYCoordinate() {
        return this._yCoordinate;
      }
      setPredictedClass(predictedClass) {
        this._predictedClass = predictedClass;
      }
      getPredictedClass() {
        return this._predictedClass;
      }
      // Returns the coordinates such that they are normalized between -1 and 1
      // relative to their pixel position on the 2D canvas.
      getNormalizedDataPoint() {
        const canvas = getCanvasObject();
        if (canvas == null) {
          return this;
        }
        const scaledX = (2 * this._xCoordinate - canvas.width) / canvas.width;
        const scaledY = -1 * ((2 * this._yCoordinate - canvas.height) / canvas.height);
        return new PerceptronDataPoint(scaledX, scaledY, this._dataClass, this._predictedClass);
      }
    }

    // Perceptron object keeps track of its weights and provides output when given input.
    class Perceptron {
      constructor() {
        this._bias = 0;
        this._wX = 1;
        this._wY = 1;
      }
      classify(dataPoint) {
        const normalizedDataPoint = dataPoint.getNormalizedDataPoint();
        const sum =
          this._bias +
          (this._wX * normalizedDataPoint.getXCoordinate()) +
          (this._wY * normalizedDataPoint.getYCoordinate());
        return 1 / (1 + Math.exp(-1 * sum)); // sigmoid
      }
      train(dataPoint, predictedValue) {
        const normalizedDataPoint = dataPoint.getNormalizedDataPoint();
        const expectedValue = normalizedDataPoint.getDataClass();
        const difference = expectedValue - predictedValue;
        this._bias += LEARNING_RATE * difference;
        this._wX += LEARNING_RATE * difference * normalizedDataPoint.getXCoordinate();
        this._wY += LEARNING_RATE * difference * normalizedDataPoint.getYCoordinate();
      }
      getHyperplaneYCoordinateAt(canvasXCoordinate) {
        const canvas = getCanvasObject();
        if (canvas == null) {
          return 0;
        }
        const scaledX = (2 * canvasXCoordinate - canvas.width) / canvas.width;
        const scaledY = (-1 * this._wX * scaledX - this._bias) / this._wY
        const canvasYCoordinate = (-1 * scaledY * canvas.height + canvas.height) / 2;
        return canvasYCoordinate;
      }
      reset() {
        this._bias = 0;
        this._wX = 1;
        this._wY = 1;
      }
    }
    const perceptron = new Perceptron();

    function getCanvasObject() {
      return document.getElementById('PerceptronCanvas');
    }

    function redrawCanvas() {
      const canvas = getCanvasObject();
      if (canvas == null) {
        return;
      }
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      // Draw the graph quadrants:
      context.strokeStyle = 'black';
      context.beginPath();
      context.moveTo(0, canvas.height / 2);
      context.lineTo(canvas.width, canvas.height / 2);
      context.stroke();
      context.beginPath();
      context.moveTo(canvas.width / 2, 0);
      context.lineTo(canvas.width / 2, canvas.height);
      context.stroke();
      // Draw the classification line if possible:
      context.strokeStyle = "orange";
      context.beginPath();
      context.moveTo(0, perceptron.getHyperplaneYCoordinateAt(0));
      context.lineTo(canvas.width, perceptron.getHyperplaneYCoordinateAt(canvas.width));
      console.log(
        perceptron.getHyperplaneYCoordinateAt(0),
        perceptron.getHyperplaneYCoordinateAt(canvas.width),
      );
      context.stroke();
      // Draw the data points:
      dataPoints.forEach(dataPoint => {
        context.fillStyle = dataPoint.getDataClass() === BLUE_CLASS_VALUE ? 'blue' : 'red';
        context.beginPath();
        context.arc(
          dataPoint.getXCoordinate(),
          dataPoint.getYCoordinate(),
          DATA_POINT_RENDER_RADIUS,
          0, // start arc angle
          2 * Math.PI, // end arc angle
        );
        context.fill();
        const predictedClass = dataPoint.getPredictedClass();
        if (predictedClass != null) {
          context.strokeStyle = predictedClass === BLUE_CLASS_VALUE ? 'blue' : 'red';
          context.beginPath();
          context.arc(
            dataPoint.getXCoordinate(),
            dataPoint.getYCoordinate(),
            DATA_POINT_RENDER_RADIUS * 2,
            0,
            2 * Math.PI,
          );
          context.stroke();
        }
      });
    }

    function onCanvasClicked(event) {
      const canvas = getCanvasObject();
      if (canvas == null) {
        return;
      }
      const dataPoint = new PerceptronDataPoint(
        event.offsetX,
        event.offsetY,
        currentlySelectedTrainingClass,
      );
      const predictedValue = perceptron.classify(dataPoint);
      const predictedClass = predictedValue >= 0.5 ? BLUE_CLASS_VALUE : RED_CLASS_VALUE;
      const predictionDisplay = document.getElementById('PerceptronOutputDisplay');
      predictionDisplay.textContent = Math.round(predictedValue * 1000) / 1000;
      // TODO: predictionDisplay.setAttribute('class', 'color: blue');
      dataPoint.setPredictedClass(predictedClass);
      perceptron.train(dataPoint, predictedValue);
      dataPoints.push(dataPoint);
      redrawCanvas();
    }

    function onControlButtonClicked(buttonName) {
      switch(buttonName) {
        case 'Blue':
          currentlySelectedTrainingClass = BLUE_CLASS_VALUE;
          document.getElementById('PerceptronBlueClassButton')
            .classList.add('PerceptronActiveClassButton');
          document.getElementById('PerceptronRedClassButton')
            .classList.remove('PerceptronActiveClassButton');
          break;
        case 'Red':
          currentlySelectedTrainingClass = RED_CLASS_VALUE;
          document.getElementById('PerceptronRedClassButton')
            .classList.add('PerceptronActiveClassButton');
          document.getElementById('PerceptronBlueClassButton')
            .classList.remove('PerceptronActiveClassButton');
          break;
        case 'Reset':
          dataPoints = [];
          perceptron.reset();
          redrawCanvas();
          break;
        case 'Train':
          break;
        case 'Retrain':
          break;
        case 'Classify':
          break;
        default:
          break;
      }
    }

    function onLearningRateChanged(event) {
      console.log('learning rate changed', event);
    }

// // get the canvas and draw it for the first time
// $(document).ready(function() {
//     document.getElementById("learning_rate_box").value = LEARNING_RATE;
//     redrawCanvas()
// });
// // train the perceptron on all existing points again
// // this may increase the accuracy of the classification
// function train() {
//     for(var i=0; i<points.length; i++) {
//         var X = points[i];
//         INPUT = scaleInput(X);
//         var output = percept.run(INPUT);
//         percept.train(INPUT, output);
//     }

//     drawAll();
// }

// // same as train, but resets the perceptron first
// function retrain() {
//     percept.reset();
//     train();
// }

// // run through all the points and have the perceptron classify them visually
// function classify() {
//     for(var i=0; i<points.length; i++) {
//         var X = points[i];
//         INPUT = scaleInput(X);
//         var output = percept.run(INPUT);
//         X.predicted = (output >= 0.5) ? 1 : -1;
//     }

//     drawAll();
// }

// // set the learning rate of the perceptron
// function setLearningRate() {
//     var rate = document.getElementById("learning_rate_box").value;
//     if(!isNaN(rate)) {
//         rate = parseFloat(rate);
//         if(rate >= 0 && rate <= 1)
//             LEARNING_RATE = rate;
//     }
// }

  </script>
</head>

<body>
  <h1>Simple Perceptron Demo</h1>
  <p>
    <canvas
      id="PerceptronCanvas"
      width="860"
      height="540"
      onload="onCanvasLoad()"
      onmousedown="onCanvasClicked(event)">
      Your browser does not support the canvas element.
    </canvas>
  </p>
  <p>
    <button
      class="PerceptronControlButton PerceptronActiveClassButton"
      id="PerceptronBlueClassButton"
      onclick="onControlButtonClicked('Blue')">
      Blue
    </button>
    <button
      class="PerceptronControlButton"
      id="PerceptronRedClassButton"
      onclick="onControlButtonClicked('Red')">
      Red
    </button>
    <button
      class="PerceptronControlButton"
      onclick="onControlButtonClicked('Reset')">
      Reset
    </button>
  </p>
  <p>
    <button
      class="PerceptronControlButton PerceptronTrainButton"
      onclick="onControlButtonClicked('Train')">
      Train
    </button>
    <button
      class="PerceptronControlButton PerceptronTrainButton"
      onclick="onControlButtonClicked('Retrain')">
      Retrain
    </button>
    <button
      class="PerceptronControlButton PerceptronClassifyButton"
      onclick="onControlButtonClicked('Classify')">
      Classify
    </button>
  </p>
  <p>
    Learning Rate:
    <input
      type="text"
      onkeypress="onLearningRateChanged(event)"/>
  </p>
  <p>
    Perceptron output value for last point added:
    <span id="PerceptronOutputDisplay">?</span>
  </p>
  <p>
    <b>Hint:</b> Bad results? Try clicking the "Train" button several times!
  </p>
</body>

</html>
