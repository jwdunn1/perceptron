<html>

<head>
  <style>
    #PerceptronCanvas {
      border: 3px solid black;
    }

    #PerceptronBlueClassButton {
      color: blue;
    }

    #PerceptronRedClassButton {
      color: red;
    }

    .PerceptronActiveClassButton {
      background-color: yellow;;
    }

    .PerceptronTrainButton {
      color: green;
    }

    .PerceptronClassifyButton {
      color: #0088AA;
    }

    .PerceptronControlButton {
      font-weight: bold;
      margin-right: 20px;
      width: 110px;
    }
  </style>

  <script type="text/javascript">
    // Global variables:
    const DATA_POINT_RENDER_RADIUS = 4;
    const LEARNING_RATE = 0.5;
    const BLUE_CLASS_NAME = 'BLUE;'
    const RED_CLASS_NAME = 'RED';

    let currentlySelectedTrainingClass = BLUE_CLASS_NAME;
    let dataPoints = [];

    class PerceptronDataPoint {
      constructor(xCoordinate, yCoordinate, dataClass, predictedClass = null) {
        this._xCoordinate = xCoordinate;
        this._yCoordinate = yCoordinate;
        this._dataClass = dataClass;
        this._predictedClass = predictedClass;
      }
      getDataClass() {
        return this._dataClass;
      }
      getXCoordinate() {
        return this._xCoordinate;
      }
      getYCoordinate() {
        return this._yCoordinate;
      }
      setPredictedClass(predictedClass) {
        this._predictedClass = predictedClass;
      }
      getPredictedClass() {
        return this._predictedClass;
      }
      // Returns the coordinates such that they are normalized between -1 and 1
      // relative to their pixel position on the 2D canvas.
      getNormalizedInput() {
        const {canvasWidth, canvasHeight} = getCanvasDimensions();
        const scaledX = (2 * this._xCoordinate - canvasWidth) / canvasWidth;
        const scaledY = -1 * ((2 * this._yCoordinate - canvasHeight) / canvasHeight);
        return new PerceptronDataPoint(scaledX, scaledY, this._dataClass, this._predictedClass);
      }
    }

    // Perceptron object keeps track of its weights and provides output when given input.
    class Perceptron {
      constructor() {
        this._bias = 0;
        this._wX = 1;
        this._wY = 1;
      }
      classify(dataPoint) {
        const normalizedDataPoint = dataPoint.getNormalizedInput();
        const sum =
          this._bias +
          (this._wX * normalizedDataPoint.x) +
          (this._wY * normalizedDataPoint.y);
        const output = 1 / (1 + Math.exp(-sum)); // sigmoid
        return output;
      }
      // // compute an output value for the given input (tuple of x and y values)
      // run(INPUT) {
      //     sum = this.bias + (this.wX * INPUT.x) + (this.wY * INPUT.y);
      //     output = 1 / (1 + Math.exp(-sum)); // sigmoid
      //     return output;
      // }
      // // train the perceptron based on its output of training item INPUT
      // this.train = function(INPUT, output) {
      //     var expected = INPUT.cls;
      //     this.bias = this.bias + LEARNING_RATE * (expected - output);
      //     this.wX = this.wX + LEARNING_RATE * (expected - output) * INPUT.x;
      //     this.wY = this.wY + LEARNING_RATE * (expected - output) * INPUT.y;
      // }
      // // computes the hyperplane (line) y value given the x coordinate.
      // // values are assumed to be in scaled (standard) coordinates (-1, +1)
      // this.hyperplane = function(x) {
      //     //( âˆ‘wixi ) + b = 0.
      //     // W.x (X) + W.y (Y) + b = 0
      //     // W.y (Y) = -W.x (X) - b
      //     // Y = (-W.x(X) - b) / W.y
      //     return ((-this.wX * x) - this.bias) / this.wY;
      // }
      reset() {
        this._bias = 0;
        this._wX = 1;
        this._wY = 1;
      }
    }
    const perceptron = new Perceptron();

    function getCanvasObject() {
      return document.getElementById('PerceptronCanvas');
    }

    function getCanvasDimensions() {
      const canvas = getCanvasObject();
      if (canvas != null) {
        return { canvasWidth: canvas.width, canvasHeight: canvas.height };
      } else {
        return { canvasWidth: 0, canvasHeight: 0 };
      }
    }

    function redrawCanvas() {
      const canvas = getCanvasObject();
      if (canvas == null) {
        return;
      }
      const context = canvas.getContext('2d');
      context.clearRect(0, 0, canvas.width, canvas.height);
      // Draw the graph quadrants:
      context.strokeStyle = 'black';
      context.beginPath();
      context.moveTo(0, canvas.height / 2);
      context.lineTo(canvas.width, canvas.height / 2);
      context.stroke();
      context.beginPath();
      context.moveTo(canvas.width / 2, 0);
      context.lineTo(canvas.width / 2, canvas.height);
      context.stroke();
      // TODO: Draw the classification line if possible:
      // context.strokeStyle = "orange";
      // context.beginPath();
      // context.moveTo(0, getLineY(0));
      // context.lineTo(canvas.width, getLineY(canvas.width));
      // context.stroke();
      // Draw the data points:
      dataPoints.forEach(dataPoint => {
        context.fillStyle = dataPoint.getDataClass() === BLUE_CLASS_NAME ? 'blue' : 'red';
        context.beginPath();
        context.arc(
          dataPoint.getXCoordinate(),
          dataPoint.getYCoordinate(),
          DATA_POINT_RENDER_RADIUS,
          0, // start arc angle
          2 * Math.PI, // end arc angle
        );
        context.fill();
        const predictedClass = dataPoint.getPredictedClass();
        if (predictedClass != null) {
          context.strokeStyle = predictedClass === BLUE_CLASS_NAME ? 'blue' : 'red';
          context.beginPath();
          context.arc(
            dataPoint.getXCoordinate(),
            dataPoint.getYCoordinate(),
            DATA_POINT_RENDER_RADIUS * 2,
            0,
            2 * Math.PI,
          );
          context.stroke();
        }
      });
    }

    function onCanvasClicked(event) {
      const canvas = getCanvasObject();
      if (canvas == null) {
        return;
      }
      const dataPoint = new PerceptronDataPoint(
        event.offsetX,
        event.offsetY,
        currentlySelectedTrainingClass,
      );
      const predictedValue = perceptron.classify(dataPoint);
      const predictedClass = predictedValue >= 0.5 ? BLUE_CLASS_NAME : RED_CLASS_NAME;
      const predictionDisplay = document.getElementById('PerceptronOutputDisplay');
      predictionDisplay.textContent = Math.round(predictedValue * 1000) / 1000;
      // TODO: predictionDisplay.setAttribute('class', 'color: blue');
      dataPoint.setPredictedClass(predictedClass);
      // TODO: perceptron.train(dataPoint, predictedValue);
      dataPoints.push(dataPoint);
      redrawCanvas();
    }

    function onControlButtonClicked(buttonName) {
      switch(buttonName) {
        case 'Blue':
          currentlySelectedTrainingClass = BLUE_CLASS_NAME;
          document.getElementById('PerceptronBlueClassButton')
            .classList.add('PerceptronActiveClassButton');
          document.getElementById('PerceptronRedClassButton')
            .classList.remove('PerceptronActiveClassButton');
          break;
        case 'Red':
          currentlySelectedTrainingClass = RED_CLASS_NAME;
          document.getElementById('PerceptronRedClassButton')
            .classList.add('PerceptronActiveClassButton');
          document.getElementById('PerceptronBlueClassButton')
            .classList.remove('PerceptronActiveClassButton');
          break;
        case 'Reset':
          dataPoints = [];
          perceptron.reset();
          redrawCanvas();
          break;
        case 'Train':
          break;
        case 'Retrain':
          break;
        case 'Classify':
          break;
        default:
          break;
      }
    }

    function onLearningRateChanged(event) {
      console.log('learning rate changed', event);
    }

// // get the canvas and draw it for the first time
// $(document).ready(function() {
//     document.getElementById("learning_rate_box").value = LEARNING_RATE;
//     redrawCanvas()
// });
// // use the perceptron to compute the hyperplane and translate it back
// // to global (canvas) coordinates
// function getLineY(x) {
//     x = (2*x - canvas.width) / canvas.width;
//     var y = percept.hyperplane(x);
//     y *= -1;
//     y *= canvas.height;
//     y += canvas.height;
//     y /= 2;
//     return y;
// }
// // train the perceptron on all existing points again
// // this may increase the accuracy of the classification
// function train() {
//     for(var i=0; i<points.length; i++) {
//         var X = points[i];
//         INPUT = scaleInput(X);
//         var output = percept.run(INPUT);
//         percept.train(INPUT, output);
//     }

//     drawAll();
// }

// // same as train, but resets the perceptron first
// function retrain() {
//     percept.reset();
//     train();
// }

// // run through all the points and have the perceptron classify them visually
// function classify() {
//     for(var i=0; i<points.length; i++) {
//         var X = points[i];
//         INPUT = scaleInput(X);
//         var output = percept.run(INPUT);
//         X.predicted = (output >= 0.5) ? 1 : -1;
//     }

//     drawAll();
// }

// // set the learning rate of the perceptron
// function setLearningRate() {
//     var rate = document.getElementById("learning_rate_box").value;
//     if(!isNaN(rate)) {
//         rate = parseFloat(rate);
//         if(rate >= 0 && rate <= 1)
//             LEARNING_RATE = rate;
//     }
// }

  </script>
</head>

<body>
  <h1>Simple Perceptron Demo</h1>
  <p>
    <canvas
      id="PerceptronCanvas"
      width="860"
      height="540"
      onload="onCanvasLoad()"
      onmousedown="onCanvasClicked(event)">
      Your browser does not support the canvas element.
    </canvas>
  </p>
  <p>
    <button
      class="PerceptronControlButton PerceptronActiveClassButton"
      id="PerceptronBlueClassButton"
      onclick="onControlButtonClicked('Blue')">
      Blue
    </button>
    <button
      class="PerceptronControlButton"
      id="PerceptronRedClassButton"
      onclick="onControlButtonClicked('Red')">
      Red
    </button>
    <button
      class="PerceptronControlButton"
      onclick="onControlButtonClicked('Reset')">
      Reset
    </button>
  </p>
  <p>
    <button
      class="PerceptronControlButton PerceptronTrainButton"
      onclick="onControlButtonClicked('Train')">
      Train
    </button>
    <button
      class="PerceptronControlButton PerceptronTrainButton"
      onclick="onControlButtonClicked('Retrain')">
      Retrain
    </button>
    <button
      class="PerceptronControlButton PerceptronClassifyButton"
      onclick="onControlButtonClicked('Classify')">
      Classify
    </button>
  </p>
  <p>
    Learning Rate:
    <input
      type="text"
      onkeypress="onLearningRateChanged(event)"/>
  </p>
  <p>
    Perceptron output value for last point added:
    <span id="PerceptronOutputDisplay">?</span>
  </p>
  <p>
    <b>Hint:</b> Bad results? Try clicking the "Train" button several times!
  </p>
</body>

</html>
